â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FONCTIONS DE LIBRAIRIE POUR MINISHELL - GUIDE COMPLET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ce fichier liste TOUTES les fonctions systÃ¨me et de librairie utiles
pour le projet minishell, avec leur prototype, leur utilitÃ© et des
exemples d'utilisation concrets.


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. LECTURE ET AFFICHAGE                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
readline() - Lire une ligne avec historique et Ã©dition
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : -lreadline
ğŸ“„ Header : <readline/readline.h>
ğŸ”§ Prototype : char *readline(const char *prompt);

âœ… UtilitÃ© :
   Affiche un prompt et lit une ligne de l'utilisateur avec:
   - Ã‰dition de ligne (flÃ¨ches gauche/droite)
   - Historique (flÃ¨ches haut/bas)
   - AutocomplÃ©tion (Tab)

ğŸ“ Exemple :
   char *line;
   
   line = readline("minishell> ");
   if (line == NULL)  // Ctrl+D ou erreur
   {
       printf("exit\n");
       exit(0);
   }
   printf("Vous avez tapÃ©: %s\n", line);
   free(line);  // âš ï¸ Ne pas oublier de free !

âš ï¸ Attention : readline() alloue de la mÃ©moire avec malloc()


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
add_history() - Ajouter une commande Ã  l'historique
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : -lreadline
ğŸ“„ Header : <readline/history.h>
ğŸ”§ Prototype : void add_history(const char *line);

âœ… UtilitÃ© :
   Ajoute une commande Ã  l'historique pour qu'elle soit
   accessible avec les flÃ¨ches haut/bas

ğŸ“ Exemple :
   char *line;
   
   line = readline("minishell> ");
   if (line && *line)  // Si la ligne n'est pas vide
   {
       add_history(line);  // Ajouter Ã  l'historique
       // ... traiter la commande
   }
   free(line);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
printf() - Afficher du texte formatÃ© sur stdout
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdio.h>
ğŸ”§ Prototype : int printf(const char *format, ...);

âœ… UtilitÃ© :
   Afficher du texte formatÃ© sur la sortie standard

ğŸ“ Exemple :
   printf("Bonjour %s!\n", "Kevin");
   printf("Nombre: %d, CaractÃ¨re: %c\n", 42, 'A');


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
write() - Ã‰crire dans un descripteur de fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : ssize_t write(int fd, const void *buf, size_t count);

âœ… UtilitÃ© :
   Ã‰crire des bytes dans un fichier ou sur stdout/stderr

ğŸ“ Exemple :
   // Ã‰crire sur stdout (fd = 1)
   write(1, "Hello\n", 6);
   
   // Ã‰crire sur stderr (fd = 2)
   write(2, "Erreur!\n", 8);
   
   // Ã‰crire dans un fichier
   int fd = open("output.txt", O_WRONLY | O_CREAT, 0644);
   write(fd, "Contenu\n", 8);
   close(fd);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. GESTION DES PROCESSUS                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
fork() - CrÃ©er un nouveau processus
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : pid_t fork(void);

âœ… UtilitÃ© :
   CrÃ©e une copie du processus actuel (parent et enfant)
   Retourne 0 dans l'enfant, PID de l'enfant dans le parent

ğŸ“ Exemple :
   pid_t pid;
   
   pid = fork();
   if (pid == -1)
   {
       perror("fork");
       exit(1);
   }
   else if (pid == 0)
   {
       // Code du processus ENFANT
       printf("Je suis l'enfant, PID = %d\n", getpid());
       exit(0);
   }
   else
   {
       // Code du processus PARENT
       printf("Je suis le parent, PID enfant = %d\n", pid);
       wait(NULL);  // Attendre l'enfant
   }


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
execve() - ExÃ©cuter un programme
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int execve(const char *path, char *const argv[], 
                          char *const envp[]);

âœ… UtilitÃ© :
   Remplace le processus actuel par un nouveau programme
   âš ï¸ Ne retourne JAMAIS en cas de succÃ¨s !

ğŸ“ Exemple :
   char *argv[] = {"ls", "-la", "/home", NULL};
   char *envp[] = {"PATH=/bin:/usr/bin", NULL};
   
   execve("/bin/ls", argv, envp);
   
   // Si on arrive ici, c'est qu'il y a eu une erreur
   perror("execve");
   exit(127);  // Code d'erreur "command not found"

ğŸ’¡ Exemple complet avec fork :
   pid_t pid = fork();
   if (pid == 0)
   {
       // Enfant : exÃ©cuter ls
       char *argv[] = {"ls", "-l", NULL};
       execve("/bin/ls", argv, envp);
       perror("execve");  // Seulement si erreur
       exit(127);
   }
   wait(NULL);  // Parent attend l'enfant


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
wait() / waitpid() - Attendre la fin d'un processus enfant
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <sys/wait.h>
ğŸ”§ Prototype : 
   pid_t wait(int *status);
   pid_t waitpid(pid_t pid, int *status, int options);

âœ… UtilitÃ© :
   Attendre qu'un processus enfant se termine et rÃ©cupÃ©rer
   son code de retour

ğŸ“ Exemple avec wait() :
   int status;
   pid_t pid;
   
   pid = wait(&status);  // Attendre N'IMPORTE QUEL enfant
   if (WIFEXITED(status))
   {
       int exit_code = WEXITSTATUS(status);
       printf("Enfant terminÃ© avec code %d\n", exit_code);
   }

ğŸ“ Exemple avec waitpid() :
   int status;
   pid_t child_pid = fork();
   
   if (child_pid == 0)
       exit(42);  // L'enfant sort avec code 42
   
   // Parent attend cet enfant spÃ©cifique
   waitpid(child_pid, &status, 0);
   printf("Code retour: %d\n", WEXITSTATUS(status));  // 42

ğŸ” Macros utiles pour status :
   WIFEXITED(status)    - True si sorti normalement
   WEXITSTATUS(status)  - Code de retour (0-255)
   WIFSIGNALED(status)  - True si tuÃ© par un signal
   WTERMSIG(status)     - NumÃ©ro du signal


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
exit() - Terminer le processus
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdlib.h>
ğŸ”§ Prototype : void exit(int status);

âœ… UtilitÃ© :
   Terminer le programme avec un code de retour

ğŸ“ Exemple :
   if (erreur_fatale)
       exit(1);  // Sortie avec erreur
   
   // Tout s'est bien passÃ©
   exit(0);  // SuccÃ¨s


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
getpid() / getppid() - Obtenir le PID
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : 
   pid_t getpid(void);   // PID du processus actuel
   pid_t getppid(void);  // PID du processus parent

âœ… UtilitÃ© :
   Obtenir l'identifiant du processus (pour $$ dans le shell)

ğŸ“ Exemple :
   printf("Mon PID: %d\n", getpid());
   printf("PID de mon parent: %d\n", getppid());


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. GESTION DES FICHIERS                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
open() - Ouvrir un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <fcntl.h>
ğŸ”§ Prototype : int open(const char *path, int flags, mode_t mode);

âœ… UtilitÃ© :
   Ouvrir un fichier et obtenir un file descriptor (fd)

ğŸ“ Exemples :
   // Lecture seule
   int fd = open("file.txt", O_RDONLY);
   
   // Ã‰criture (crÃ©er si n'existe pas, tronquer si existe)
   int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
   
   // Append (ajouter Ã  la fin)
   int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
   
   if (fd == -1)
   {
       perror("open");
       return (1);
   }
   
   // ... utiliser fd ...
   close(fd);

ğŸ” Flags importants :
   O_RDONLY    - Lecture seule
   O_WRONLY    - Ã‰criture seule
   O_RDWR      - Lecture et Ã©criture
   O_CREAT     - CrÃ©er si n'existe pas
   O_TRUNC     - Vider le fichier Ã  l'ouverture
   O_APPEND    - Ã‰crire Ã  la fin

ğŸ” Permissions (mode) :
   0644        - rw-r--r-- (propriÃ©taire lit/Ã©crit, autres lisent)
   0755        - rwxr-xr-x (propriÃ©taire tout, autres lis/exec)


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
close() - Fermer un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int close(int fd);

âœ… UtilitÃ© :
   Fermer un file descriptor

ğŸ“ Exemple :
   int fd = open("file.txt", O_RDONLY);
   // ... lire le fichier ...
   close(fd);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
read() - Lire depuis un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : ssize_t read(int fd, void *buf, size_t count);

âœ… UtilitÃ© :
   Lire des bytes depuis un fichier/stdin

ğŸ“ Exemple :
   char buffer[1024];
   int fd = open("file.txt", O_RDONLY);
   ssize_t bytes_read;
   
   bytes_read = read(fd, buffer, sizeof(buffer) - 1);
   if (bytes_read > 0)
   {
       buffer[bytes_read] = '\0';  // Terminer la chaÃ®ne
       printf("Lu: %s\n", buffer);
   }
   close(fd);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
access() - VÃ©rifier l'accÃ¨s Ã  un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int access(const char *path, int mode);

âœ… UtilitÃ© :
   VÃ©rifier si un fichier existe et/ou si on a les permissions

ğŸ“ Exemple :
   // VÃ©rifier si le fichier existe
   if (access("file.txt", F_OK) == 0)
       printf("Le fichier existe\n");
   
   // VÃ©rifier si exÃ©cutable
   if (access("/bin/ls", X_OK) == 0)
       printf("ls est exÃ©cutable\n");
   
   // VÃ©rifier lecture et Ã©criture
   if (access("file.txt", R_OK | W_OK) == 0)
       printf("Fichier lisible et modifiable\n");

ğŸ” Modes :
   F_OK    - Le fichier existe
   R_OK    - Lecture possible
   W_OK    - Ã‰criture possible
   X_OK    - ExÃ©cution possible


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
unlink() - Supprimer un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int unlink(const char *path);

âœ… UtilitÃ© :
   Supprimer un fichier du systÃ¨me de fichiers

ğŸ“ Exemple :
   // Supprimer un fichier temporaire
   if (unlink("/tmp/heredoc_tmp") == -1)
       perror("unlink");


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
stat() - Obtenir les informations d'un fichier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <sys/stat.h>
ğŸ”§ Prototype : int stat(const char *path, struct stat *buf);

âœ… UtilitÃ© :
   Obtenir les mÃ©tadonnÃ©es d'un fichier (taille, type, etc.)

ğŸ“ Exemple :
   struct stat file_stat;
   
   if (stat("file.txt", &file_stat) == 0)
   {
       printf("Taille: %ld bytes\n", file_stat.st_size);
       
       if (S_ISDIR(file_stat.st_mode))
           printf("C'est un dossier\n");
       else if (S_ISREG(file_stat.st_mode))
           printf("C'est un fichier rÃ©gulier\n");
   }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. REDIRECTIONS (DUPLICATION DE FD)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
dup() / dup2() - Dupliquer un file descriptor
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : 
   int dup(int oldfd);
   int dup2(int oldfd, int newfd);

âœ… UtilitÃ© :
   CrÃ©er une copie d'un fd pour rediriger stdin/stdout/stderr

ğŸ“ Exemple - Redirection de sortie (>) :
   int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
   int stdout_backup = dup(STDOUT_FILENO);  // Sauvegarder stdout
   
   dup2(fd, STDOUT_FILENO);  // stdout pointe maintenant vers le fichier
   close(fd);
   
   printf("Ceci va dans output.txt\n");
   
   dup2(stdout_backup, STDOUT_FILENO);  // Restaurer stdout
   close(stdout_backup);
   printf("Ceci va sur le terminal\n");

ğŸ“ Exemple - Redirection d'entrÃ©e (<) :
   int fd = open("input.txt", O_RDONLY);
   dup2(fd, STDIN_FILENO);  // stdin lit maintenant depuis le fichier
   close(fd);
   
   char buffer[100];
   scanf("%s", buffer);  // Lit depuis input.txt au lieu du clavier

ğŸ’¡ FD standards :
   STDIN_FILENO  = 0
   STDOUT_FILENO = 1
   STDERR_FILENO = 2


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pipe() - CrÃ©er un tube de communication
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int pipe(int pipefd[2]);

âœ… UtilitÃ© :
   CrÃ©er un pipe pour connecter la sortie d'un processus
   Ã  l'entrÃ©e d'un autre (pour les |)

ğŸ“ Exemple simple :
   int pipefd[2];  // [0] = lecture, [1] = Ã©criture
   pipe(pipefd);
   
   if (fork() == 0)
   {
       // Enfant: Ã©crire dans le pipe
       close(pipefd[0]);  // Fermer la lecture
       write(pipefd[1], "Hello", 5);
       close(pipefd[1]);
       exit(0);
   }
   else
   {
       // Parent: lire depuis le pipe
       char buffer[100];
       close(pipefd[1]);  // Fermer l'Ã©criture
       read(pipefd[0], buffer, sizeof(buffer));
       close(pipefd[0]);
       printf("ReÃ§u: %s\n", buffer);
       wait(NULL);
   }

ğŸ“ Exemple - Commande avec pipe (ls | grep txt) :
   int pipefd[2];
   pipe(pipefd);
   
   if (fork() == 0)
   {
       // Enfant 1: ls
       close(pipefd[0]);  // Pas besoin de lire
       dup2(pipefd[1], STDOUT_FILENO);  // stdout â†’ pipe
       close(pipefd[1]);
       execve("/bin/ls", (char*[]){"ls", NULL}, envp);
   }
   
   if (fork() == 0)
   {
       // Enfant 2: grep
       close(pipefd[1]);  // Pas besoin d'Ã©crire
       dup2(pipefd[0], STDIN_FILENO);  // stdin â† pipe
       close(pipefd[0]);
       execve("/bin/grep", (char*[]){"grep", "txt", NULL}, envp);
   }
   
   // Parent
   close(pipefd[0]);
   close(pipefd[1]);
   wait(NULL);
   wait(NULL);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. GESTION DES RÃ‰PERTOIRES                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
chdir() - Changer de rÃ©pertoire
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : int chdir(const char *path);

âœ… UtilitÃ© :
   Changer le rÃ©pertoire courant (pour la commande cd)

ğŸ“ Exemple :
   if (chdir("/home/user") == -1)
   {
       perror("chdir");
       return (1);
   }
   printf("RÃ©pertoire changÃ© avec succÃ¨s\n");


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
getcwd() - Obtenir le rÃ©pertoire courant
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Prototype : char *getcwd(char *buf, size_t size);

âœ… UtilitÃ© :
   Obtenir le chemin absolu du rÃ©pertoire actuel (pour pwd)

ğŸ“ Exemple :
   char cwd[1024];
   
   if (getcwd(cwd, sizeof(cwd)) != NULL)
       printf("RÃ©pertoire actuel: %s\n", cwd);
   else
       perror("getcwd");


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
opendir() / readdir() / closedir() - Lire un rÃ©pertoire
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <dirent.h>
ğŸ”§ Prototype : 
   DIR *opendir(const char *name);
   struct dirent *readdir(DIR *dirp);
   int closedir(DIR *dirp);

âœ… UtilitÃ© :
   Lister les fichiers d'un rÃ©pertoire (pour bonus wildcards)

ğŸ“ Exemple :
   DIR *dir;
   struct dirent *entry;
   
   dir = opendir(".");
   if (dir == NULL)
   {
       perror("opendir");
       return (1);
   }
   
   while ((entry = readdir(dir)) != NULL)
   {
       // Ignorer . et ..
       if (strcmp(entry->d_name, ".") && strcmp(entry->d_name, ".."))
           printf("%s\n", entry->d_name);
   }
   
   closedir(dir);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. VARIABLES D'ENVIRONNEMENT                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
getenv() - Obtenir une variable d'environnement
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdlib.h>
ğŸ”§ Prototype : char *getenv(const char *name);

âœ… UtilitÃ© :
   RÃ©cupÃ©rer la valeur d'une variable d'environnement

ğŸ“ Exemple :
   char *path = getenv("PATH");
   if (path)
       printf("PATH = %s\n", path);
   else
       printf("PATH non dÃ©fini\n");
   
   char *home = getenv("HOME");
   char *user = getenv("USER");

âš ï¸ Attention : Ne pas modifier la chaÃ®ne retournÃ©e !


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
environ - Tableau de toutes les variables d'environnement
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <unistd.h>
ğŸ”§ Variable globale : extern char **environ;

âœ… UtilitÃ© :
   AccÃ©der Ã  toutes les variables d'environnement

ğŸ“ Exemple :
   extern char **environ;
   int i = 0;
   
   while (environ[i])
   {
       printf("%s\n", environ[i]);
       i++;
   }

ğŸ’¡ Format : "NOM=valeur"


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. SIGNAUX                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
signal() - GÃ©rer un signal (version simple)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <signal.h>
ğŸ”§ Prototype : void (*signal(int sig, void (*handler)(int)))(int);

âœ… UtilitÃ© :
   DÃ©finir une action quand un signal est reÃ§u

ğŸ“ Exemple :
   void handle_sigint(int sig)
   {
       (void)sig;
       write(1, "\n", 1);
       // Afficher un nouveau prompt
   }
   
   int main(void)
   {
       signal(SIGINT, handle_sigint);  // Ctrl+C
       signal(SIGQUIT, SIG_IGN);       // Ignorer Ctrl+\
       
       while (1)
       {
           // Boucle du shell
       }
   }


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
sigaction() - GÃ©rer un signal (version avancÃ©e)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <signal.h>
ğŸ”§ Prototype : int sigaction(int sig, const struct sigaction *act,
                             struct sigaction *oldact);

âœ… UtilitÃ© :
   Version plus robuste et configurable que signal()

ğŸ“ Exemple :
   void handle_sigint(int sig)
   {
       (void)sig;
       write(1, "\nminishell> ", 12);
   }
   
   int main(void)
   {
       struct sigaction sa;
       
       sa.sa_handler = handle_sigint;
       sa.sa_flags = SA_RESTART;  // RedÃ©marrer les appels systÃ¨me
       sigemptyset(&sa.sa_mask);
       
       sigaction(SIGINT, &sa, NULL);
       
       // ...
   }

ğŸ” Signaux importants :
   SIGINT  (2)  - Ctrl+C
   SIGQUIT (3)  - Ctrl+\
   SIGTERM (15) - Terminaison propre
   SIGKILL (9)  - Terminaison forcÃ©e (non capturable)


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
kill() - Envoyer un signal Ã  un processus
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <signal.h>
ğŸ”§ Prototype : int kill(pid_t pid, int sig);

âœ… UtilitÃ© :
   Envoyer un signal Ã  un processus spÃ©cifique

ğŸ“ Exemple :
   pid_t child_pid = 12345;
   
   // Terminer proprement
   kill(child_pid, SIGTERM);
   
   // Forcer l'arrÃªt
   kill(child_pid, SIGKILL);
   
   // Envoyer SIGINT (comme Ctrl+C)
   kill(child_pid, SIGINT);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. GESTION DE LA MÃ‰MOIRE                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
malloc() - Allouer de la mÃ©moire
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdlib.h>
ğŸ”§ Prototype : void *malloc(size_t size);

âœ… UtilitÃ© :
   Allouer de la mÃ©moire dynamiquement

ğŸ“ Exemple :
   char *str = malloc(100);
   if (str == NULL)
   {
       perror("malloc");
       return (1);
   }
   strcpy(str, "Hello");
   // ... utiliser str ...
   free(str);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
free() - LibÃ©rer de la mÃ©moire
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdlib.h>
ğŸ”§ Prototype : void free(void *ptr);

âœ… UtilitÃ© :
   LibÃ©rer la mÃ©moire allouÃ©e par malloc/calloc/realloc

ğŸ“ Exemple :
   char *str = malloc(100);
   // ... utiliser str ...
   free(str);
   str = NULL;  // Bonne pratique


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. MANIPULATION DE CHAÃNES                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strlen() - Longueur d'une chaÃ®ne
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <string.h>
ğŸ”§ Prototype : size_t strlen(const char *s);

ğŸ“ Exemple :
   char *str = "Hello";
   printf("Longueur: %zu\n", strlen(str));  // 5


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strcmp() / strncmp() - Comparer des chaÃ®nes
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <string.h>
ğŸ”§ Prototype : 
   int strcmp(const char *s1, const char *s2);
   int strncmp(const char *s1, const char *s2, size_t n);

ğŸ“ Exemple :
   if (strcmp(cmd, "exit") == 0)
       printf("Commande exit dÃ©tectÃ©e\n");
   
   if (strncmp(cmd, "echo", 4) == 0)
       printf("Commande echo\n");


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strcpy() / strncpy() - Copier une chaÃ®ne
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <string.h>
ğŸ”§ Prototype : 
   char *strcpy(char *dest, const char *src);
   char *strncpy(char *dest, const char *src, size_t n);

ğŸ“ Exemple :
   char dest[100];
   strcpy(dest, "Hello");
   
   // Plus sÃ»r avec strncpy
   strncpy(dest, "Hello", sizeof(dest) - 1);
   dest[sizeof(dest) - 1] = '\0';


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strdup() - Dupliquer une chaÃ®ne
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : SystÃ¨me
ğŸ“„ Header : <string.h>
ğŸ”§ Prototype : char *strdup(const char *s);

âœ… UtilitÃ© :
   Allouer et copier une chaÃ®ne (malloc + strcpy)

ğŸ“ Exemple :
   char *original = "Hello";
   char *copy = strdup(original);
   
   // copy est allouÃ©e dynamiquement
   printf("%s\n", copy);
   free(copy);  // âš ï¸ Ne pas oublier !


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strjoin() - ConcatÃ©ner deux chaÃ®nes (Ã€ CODER)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ Prototype : char *ft_strjoin(char const *s1, char const *s2);

âœ… UtilitÃ© :
   CrÃ©er une nouvelle chaÃ®ne = s1 + s2

ğŸ“ Exemple d'implÃ©mentation :
   char *ft_strjoin(char const *s1, char const *s2)
   {
       char *result;
       size_t len;
       
       if (!s1 || !s2)
           return (NULL);
       len = strlen(s1) + strlen(s2);
       result = malloc(len + 1);
       if (!result)
           return (NULL);
       strcpy(result, s1);
       strcat(result, s2);
       return (result);
   }
   
   // Utilisation
   char *path = ft_strjoin("/usr/bin/", "ls");
   // path = "/usr/bin/ls"
   free(path);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
split() - DÃ©couper une chaÃ®ne (Ã€ CODER)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ Prototype : char **ft_split(char const *s, char c);

âœ… UtilitÃ© :
   DÃ©couper une chaÃ®ne selon un dÃ©limiteur

ğŸ“ Exemple :
   char **paths = ft_split("/bin:/usr/bin:/usr/local/bin", ':');
   // paths[0] = "/bin"
   // paths[1] = "/usr/bin"
   // paths[2] = "/usr/local/bin"
   // paths[3] = NULL
   
   int i = 0;
   while (paths[i])
   {
       printf("%s\n", paths[i]);
       free(paths[i]);
       i++;
   }
   free(paths);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 10. GESTION DES ERREURS                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
perror() - Afficher un message d'erreur
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdio.h>
ğŸ”§ Prototype : void perror(const char *s);

âœ… UtilitÃ© :
   Afficher un message d'erreur basÃ© sur errno

ğŸ“ Exemple :
   int fd = open("fichier_inexistant", O_RDONLY);
   if (fd == -1)
   {
       perror("open");  // Affiche: "open: No such file or directory"
       return (1);
   }


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
strerror() - Obtenir un message d'erreur
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <string.h>
ğŸ”§ Prototype : char *strerror(int errnum);

âœ… UtilitÃ© :
   Obtenir le message d'erreur correspondant Ã  errno

ğŸ“ Exemple :
   int fd = open("fichier_inexistant", O_RDONLY);
   if (fd == -1)
   {
       printf("Erreur: %s\n", strerror(errno));
       // Affiche: "Erreur: No such file or directory"
   }


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
errno - Variable globale d'erreur
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <errno.h>
ğŸ”§ Variable : extern int errno;

âœ… UtilitÃ© :
   Contient le code d'erreur de la derniÃ¨re fonction systÃ¨me

ğŸ“ Exemple :
   #include <errno.h>
   
   int fd = open("file.txt", O_RDONLY);
   if (fd == -1)
   {
       if (errno == ENOENT)
           printf("Fichier introuvable\n");
       else if (errno == EACCES)
           printf("Permission refusÃ©e\n");
       else
           printf("Erreur: %s\n", strerror(errno));
   }

ğŸ” Codes d'erreur courants :
   ENOENT   - No such file or directory
   EACCES   - Permission denied
   ENOMEM   - Out of memory
   EINVAL   - Invalid argument


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 11. CONVERSION ET UTILITAIRES                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
atoi() - Convertir chaÃ®ne en entier
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <stdlib.h>
ğŸ”§ Prototype : int atoi(const char *str);

ğŸ“ Exemple :
   char *str = "42";
   int n = atoi(str);  // n = 42
   
   // Pour exit
   if (strcmp(cmd, "exit") == 0)
   {
       int code = atoi(args[1]);
       exit(code);
   }


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
itoa() - Convertir entier en chaÃ®ne (Ã€ CODER)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ Prototype : char *ft_itoa(int n);

âœ… UtilitÃ© :
   Convertir un nombre en chaÃ®ne (pour $? par exemple)

ğŸ“ Exemple :
   int exit_code = 127;
   char *str = ft_itoa(exit_code);  // str = "127"
   printf("Code: %s\n", str);
   free(str);


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
isalpha() / isdigit() / isalnum() - Tester un caractÃ¨re
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Librairie : Standard C
ğŸ“„ Header : <ctype.h>
ğŸ”§ Prototype : 
   int isalpha(int c);  // Lettre ?
   int isdigit(int c);  // Chiffre ?
   int isalnum(int c);  // Lettre ou chiffre ?

ğŸ“ Exemple :
   char c = 'A';
   if (isalpha(c))
       printf("C'est une lettre\n");
   
   // VÃ©rifier si un nom de variable est valide
   int is_valid_var(char *name)
   {
       if (!isalpha(name[0]) && name[0] != '_')
           return (0);  // Doit commencer par lettre ou _
       int i = 1;
       while (name[i])
       {
           if (!isalnum(name[i]) && name[i] != '_')
               return (0);
           i++;
       }
       return (1);
   }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“š RÃ‰CAPITULATIF PAR CATÃ‰GORIE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”µ LECTURE/AFFICHAGE
   readline, add_history, printf, write

ğŸ”µ PROCESSUS
   fork, execve, wait, waitpid, exit, getpid

ğŸ”µ FICHIERS
   open, close, read, access, unlink, stat

ğŸ”µ REDIRECTIONS
   dup, dup2, pipe

ğŸ”µ RÃ‰PERTOIRES
   chdir, getcwd, opendir, readdir, closedir

ğŸ”µ ENVIRONNEMENT
   getenv, environ

ğŸ”µ SIGNAUX
   signal, sigaction, kill

ğŸ”µ MÃ‰MOIRE
   malloc, free

ğŸ”µ CHAÃNES
   strlen, strcmp, strcpy, strdup, strjoin (Ã  coder), split (Ã  coder)

ğŸ”µ ERREURS
   perror, strerror, errno

ğŸ”µ CONVERSION
   atoi, itoa (Ã  coder), isalpha, isdigit


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’¡ CONSEILS IMPORTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Toujours vÃ©rifier les valeurs de retour (-1 pour les erreurs)
âœ… Utiliser perror() pour afficher les erreurs systÃ¨me
âœ… Fermer tous les fd ouverts (close)
âœ… Free toute la mÃ©moire allouÃ©e
âœ… Tester avec valgrind pour les leaks
âœ… Lire les man pages : man 2 fork, man 3 malloc, etc.
   (man 2 = appels systÃ¨me, man 3 = fonctions librairie)

ğŸ” Commandes utiles pour tester :
   valgrind --leak-check=full ./minishell
   strace ./minishell  (voir les appels systÃ¨me)
   nm minishell | grep U  (voir les fonctions utilisÃ©es)
