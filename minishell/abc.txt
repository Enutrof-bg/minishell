â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GUIDE COMPLET MINISHELL - Ã‰TAPE PAR Ã‰TAPE POUR DÃ‰BUTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ INTRODUCTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ce guide explique comment reconstruire un minishell (un petit shell comme bash)
depuis zÃ©ro. Chaque Ã©tape est expliquÃ©e simplement avec son objectif.


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 1 : STRUCTURE DE BASE ET INITIALISATION                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 1 : CrÃ©er la structure principale du programme
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : main.c, minishell.h
ğŸ¯ But : Avoir un point d'entrÃ©e qui lance le shell et affiche un prompt

Ce qu'il faut faire :
- CrÃ©er la fonction main() qui sera le cÅ“ur du programme
- Afficher un prompt (exemple: "minishell> ") pour inviter l'utilisateur
- CrÃ©er une boucle infinie qui attend les commandes de l'utilisateur
- Permettre de quitter proprement avec exit ou Ctrl+D


Ã‰TAPE 2 : GÃ©rer les variables d'environnement
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : main_init_env.c
ğŸ¯ But : RÃ©cupÃ©rer et stocker les variables d'environnement (PATH, HOME, etc.)

Ce qu'il faut faire :
- Copier l'environnement (char **envp) dans une structure propre
- CrÃ©er des fonctions pour chercher une variable (get_env)
- CrÃ©er des fonctions pour modifier/ajouter des variables (set_env)
- Stocker tout Ã§a dans une liste chaÃ®nÃ©e ou tableau


Ã‰TAPE 3 : Installer readline pour la saisie
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : read_input.c
ğŸ¯ But : Permettre Ã  l'utilisateur de taper des commandes avec historique

Ce qu'il faut faire :
- Utiliser la fonction readline() pour lire l'entrÃ©e utilisateur
- Ajouter chaque commande Ã  l'historique (add_history)
- GÃ©rer les flÃ¨ches haut/bas pour naviguer dans l'historique


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 2 : PARSING (ANALYSE DE LA COMMANDE) - DÃ‰TAILLÃ‰         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 4 : Tokenisation basique
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_parsing_1.c, parsing_lst_utils.c
ğŸ¯ But : DÃ©couper la ligne de commande en morceaux (tokens)

ğŸ” EXPLICATION DÃ‰TAILLÃ‰E :
Le parsing commence par transformer une longue chaÃ®ne de caractÃ¨res en 
Ã©lÃ©ments individuels qu'on peut manipuler. C'est comme dÃ©couper une phrase
en mots.

ğŸ“ EXEMPLES CONCRETS :

Exemple 1 - Commande simple :
  EntrÃ©e :  "ls -la"
  Tokens :  ["ls"] â†’ ["-la"]
  
Exemple 2 - Espaces multiples :
  EntrÃ©e :  "echo    hello     world"
  Tokens :  ["echo"] â†’ ["hello"] â†’ ["world"]
  (Les espaces multiples sont ignorÃ©s)

Exemple 3 - Avec opÃ©rateurs :
  EntrÃ©e :  "cat file.txt > output.txt"
  Tokens :  ["cat"] â†’ ["file.txt"] â†’ [">"] â†’ ["output.txt"]

âš™ï¸ ALGORITHME :
1. Parcourir la chaÃ®ne caractÃ¨re par caractÃ¨re
2. Si on trouve un espace â†’ crÃ©er un nouveau token
3. Si on trouve un opÃ©rateur (<, >, |) â†’ token sÃ©parÃ©
4. Ajouter chaque token dans une liste chaÃ®nÃ©e

ğŸ’¾ STRUCTURE DE DONNÃ‰ES :
typedef struct s_token {
    char            *content;    // Le texte du token
    int             type;        // WORD, PIPE, REDIR_IN, etc.
    struct s_token  *next;       // Token suivant
}   t_token;


Ã‰TAPE 5 : GÃ©rer les quotes (guillemets)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_parsing_2_single.c, parsing_parsing_2_double.c
ğŸ¯ But : Respecter les guillemets simples et doubles comme bash

ğŸ” EXPLICATION DÃ‰TAILLÃ‰E :
Les quotes permettent de grouper plusieurs mots en un seul argument et
de contrÃ´ler l'expansion des variables. C'est crucial pour gÃ©rer les
espaces dans les noms de fichiers et protÃ©ger certains caractÃ¨res.

ğŸ“ EXEMPLES CONCRETS :

Exemple 1 - Simple quotes (pas d'expansion) :
  EntrÃ©e :  echo 'Hello $USER'
  Tokens :  ["echo"] â†’ ["Hello $USER"]
  RÃ©sultat affichÃ© : Hello $USER
  âš ï¸ Le $USER n'est PAS remplacÃ© !

Exemple 2 - Double quotes (avec expansion) :
  EntrÃ©e :  echo "Hello $USER"
  Tokens :  ["echo"] â†’ ["Hello $USER"]
  AprÃ¨s expansion : ["echo"] â†’ ["Hello kevin"]
  RÃ©sultat affichÃ© : Hello kevin
  âœ… Le $USER est remplacÃ© par sa valeur !

Exemple 3 - Espaces dans les quotes :
  EntrÃ©e :  echo "un deux trois"
  Tokens :  ["echo"] â†’ ["un deux trois"]
  âš ï¸ C'est UN SEUL argument, pas trois !

Exemple 4 - Fichier avec espaces :
  EntrÃ©e :  cat "mon fichier.txt"
  Tokens :  ["cat"] â†’ ["mon fichier.txt"]
  âœ… Le nom de fichier est bien groupÃ©

Exemple 5 - Mixte :
  EntrÃ©e :  echo 'pas de $USER' "mais si $USER"
  Tokens :  ["echo"] â†’ ["pas de $USER"] â†’ ["mais si kevin"]

Exemple 6 - Quotes non fermÃ©es (erreur) :
  EntrÃ©e :  echo "hello
  RÃ©sultat : Erreur de parsing - quote non fermÃ©e
  ğŸ’¡ Bash affiche : > (attend la suite)
  ğŸ’¡ Minishell : Affiche une erreur

âš™ï¸ ALGORITHME :
1. DÃ©tecter une quote ouvrante (' ou ")
2. Continuer Ã  lire jusqu'Ã  trouver la quote fermante
3. Tout ce qui est entre les quotes = un seul token
4. Marquer le token avec son type (SINGLE_QUOTE ou DOUBLE_QUOTE)
5. Si EOF avant la quote fermante â†’ erreur

ğŸ¯ Ã‰TAT Ã€ MAINTENIR :
- in_single_quote : boolÃ©en (sommes-nous dans des ' ?)
- in_double_quote : boolÃ©en (sommes-nous dans des " ?)
- quote_char : quel type de quote a Ã©tÃ© ouvert


Ã‰TAPE 6 : Expansion des variables ($)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_dollar.c, parsing_dollar_handle.c
ğŸ¯ But : Remplacer $VARIABLE par sa valeur

ğŸ” EXPLICATION DÃ‰TAILLÃ‰E :
L'expansion des variables permet d'utiliser des valeurs dynamiques dans
les commandes. Le shell remplace $NOM par la valeur de la variable NOM.

ğŸ“ EXEMPLES CONCRETS :

Exemple 1 - Variable simple :
  Commande : echo $USER
  $USER = "kevin"
  AprÃ¨s expansion : echo kevin
  RÃ©sultat : kevin

Exemple 2 - Variable au milieu :
  Commande : echo Bonjour_$USER_bienvenue
  $USER = "kevin"
  AprÃ¨s expansion : echo Bonjour_kevin_bienvenue
  RÃ©sultat : Bonjour_kevin_bienvenue

Exemple 3 - Variable inexistante :
  Commande : echo $VAR_INEXISTANTE
  AprÃ¨s expansion : echo 
  RÃ©sultat : (ligne vide)
  ğŸ’¡ Pas d'erreur, juste une chaÃ®ne vide

Exemple 4 - $? (code de retour) :
  Commande prÃ©cÃ©dente : ls /dossier_qui_existe_pas (erreur)
  Commande : echo $?
  RÃ©sultat : 1 (ou 2, selon l'erreur)
  
  Commande prÃ©cÃ©dente : ls (succÃ¨s)
  Commande : echo $?
  RÃ©sultat : 0

Exemple 5 - Multiples variables :
  Commande : echo $USER $HOME $PWD
  AprÃ¨s expansion : echo kevin /home/kevin /home/kevin/Documents
  RÃ©sultat : kevin /home/kevin /home/kevin/Documents

Exemple 6 - Dans les double quotes :
  Commande : echo "$USER est dans $PWD"
  AprÃ¨s expansion : echo "kevin est dans /home/kevin/Documents"
  RÃ©sultat : kevin est dans /home/kevin/Documents

Exemple 7 - Dans les simple quotes (PAS d'expansion) :
  Commande : echo '$USER est dans $PWD'
  AprÃ¨s expansion : echo '$USER est dans $PWD'
  RÃ©sultat : $USER est dans $PWD
  âš ï¸ Aucune expansion dans les simple quotes !

Exemple 8 - $ seul :
  Commande : echo $
  RÃ©sultat : $ (littÃ©ral)

Exemple 9 - $$ (PID du shell) :
  Commande : echo $$
  RÃ©sultat : 12345 (le PID du processus minishell)

âš™ï¸ ALGORITHME D'EXPANSION :
1. Parcourir le token caractÃ¨re par caractÃ¨re
2. Si on trouve un $ ET qu'on n'est PAS dans des single quotes :
   a. Extraire le nom de la variable (lettres, chiffres, _)
   b. Chercher la variable dans l'environnement
   c. Remplacer $VAR par sa valeur
   d. Si pas trouvÃ©e â†’ remplacer par chaÃ®ne vide
3. Reconstruire le token avec les valeurs remplacÃ©es

ğŸ¯ CAS SPÃ‰CIAUX Ã€ GÃ‰RER :
- $? â†’ Code retour de la derniÃ¨re commande
- $$ â†’ PID du shell
- $0 Ã  $9 â†’ Arguments du script (pas pour minishell)
- $ suivi d'un espace â†’ $ littÃ©ral
- $123abc â†’ Variable nommÃ©e "123abc" (invalide, devient vide)

ğŸ’¡ ORDRE DE TRAITEMENT :
1. D'abord identifier les quotes
2. Puis expanser les variables (sauf dans single quotes)
3. Enfin supprimer les quotes


Ã‰TAPE 7 : Supprimer les quotes aprÃ¨s traitement
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_delete_quote.c
ğŸ¯ But : Enlever les guillemets aprÃ¨s avoir traitÃ© leur contenu

ğŸ” EXPLICATION DÃ‰TAILLÃ‰E :
Une fois que les quotes ont servi Ã  grouper les arguments et contrÃ´ler
l'expansion, on doit les retirer. L'utilisateur ne veut pas voir les
guillemets dans le rÃ©sultat final.

ğŸ“ EXEMPLES CONCRETS :

Exemple 1 - Simple :
  Avant : ["echo"] â†’ ["\"hello\""]
  AprÃ¨s : ["echo"] â†’ ["hello"]
  
Exemple 2 - Avec espaces :
  Avant : ["echo"] â†’ ["\"hello world\""]
  AprÃ¨s : ["echo"] â†’ ["hello world"]
  ğŸ’¡ L'espace reste car il Ã©tait protÃ©gÃ© par les quotes

Exemple 3 - Simple quotes :
  Avant : ["echo"] â†’ ["'$USER'"]
  AprÃ¨s : ["echo"] â†’ ["$USER"]
  ğŸ’¡ On garde le $USER littÃ©ral (pas expansÃ©)

Exemple 4 - Multiples quotes dans un token :
  Avant : ["echo"] â†’ ["'hello'"world""]
  AprÃ¨s : ["echo"] â†’ ["helloworld"]
  ğŸ’¡ Les deux parties sont concatÃ©nÃ©es

Exemple 5 - Quote Ã  l'intÃ©rieur :
  Avant : ["echo"] â†’ ["\"l'ami\""]
  AprÃ¨s : ["echo"] â†’ ["l'ami"]

âš™ï¸ ALGORITHME :
1. Parcourir chaque token
2. CrÃ©er une nouvelle chaÃ®ne sans les quotes de dÃ©limitation
3. Garder les caractÃ¨res entre les quotes
4. Remplacer le token par la nouvelle chaÃ®ne

ğŸ”„ PROCESSUS COMPLET DU PARSING (Ã‰TAPES 4-7) :

Exemple complet : echo "Hello $USER" 'world' > file.txt

â”‚ Ã‰TAPE 4 - Tokenisation â”‚
EntrÃ©e : echo "Hello $USER" 'world' > file.txt
Tokens : [echo] ["Hello $USER"] ['world'] [>] [file.txt]

â”‚ Ã‰TAPE 5 - Identification des quotes â”‚
[echo] â†’ type: WORD
["Hello $USER"] â†’ type: DOUBLE_QUOTE
['world'] â†’ type: SINGLE_QUOTE
[>] â†’ type: REDIR_OUT
[file.txt] â†’ type: WORD

â”‚ Ã‰TAPE 6 - Expansion des variables â”‚
[echo] â†’ [echo] (pas de $)
["Hello $USER"] â†’ ["Hello kevin"] (expansion car double quote)
['world'] â†’ ['world'] (pas d'expansion car single quote)
[>] â†’ [>] (opÃ©rateur)
[file.txt] â†’ [file.txt] (pas de $)

â”‚ Ã‰TAPE 7 - Suppression des quotes â”‚
[echo] â†’ [echo]
["Hello kevin"] â†’ [Hello kevin]
['world'] â†’ [world]
[>] â†’ [>]
[file.txt] â†’ [file.txt]

â”‚ RÃ‰SULTAT FINAL â”‚
Commande : echo
Arguments : ["Hello kevin", "world"]
Redirection : STDOUT vers "file.txt"

ğŸ’¡ ASTUCE POUR DÃ‰BUGGER :
Affiche les tokens aprÃ¨s chaque Ã©tape pour voir la transformation :
printf("Token %d: [%s] type=%d\n", i, token->content, token->type);


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 3 : REDIRECTIONS ET PIPES                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 8 : DÃ©tecter les redirections
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_redir.c, parsing_triple_tab_input.c, parsing_triple_tab_output.c
ğŸ¯ But : Identifier oÃ¹ rediriger l'entrÃ©e/sortie

Types de redirections :
- < fichier  : Lire depuis un fichier (entrÃ©e)
- > fichier  : Ã‰crire dans un fichier (sortie, Ã©crase)
- >> fichier : Ajouter Ã  la fin d'un fichier (sortie, append)
- << dÃ©limiteur : Heredoc (lire jusqu'Ã  voir le dÃ©limiteur)

Ce qu'il faut faire :
- Trouver les symboles <, >, >>, << dans les tokens
- Stocker le type de redirection et le nom du fichier
- Retirer ces tokens de la liste de commandes


Ã‰TAPE 9 : GÃ©rer les heredocs (<<)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_triple_tab_heredoc.c, parsing_triple_tab_heredoc_2.c
ğŸ¯ But : Lire plusieurs lignes jusqu'Ã  un dÃ©limiteur

Ce qu'il faut faire :
- Lire l'entrÃ©e ligne par ligne jusqu'au dÃ©limiteur
- Stocker le contenu dans un fichier temporaire ou pipe
- Expanser les variables dans le heredoc (sauf si dÃ©limiteur entre quotes)


Ã‰TAPE 10 : GÃ©rer les pipes (|)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_triple_tab_pipe.c
ğŸ¯ But : DÃ©couper la commande en plusieurs commandes reliÃ©es par pipes

Ce qu'il faut faire :
- DÃ©tecter le symbole |
- SÃ©parer : "ls | grep test" â†’ commande1: "ls", commande2: "grep test"
- CrÃ©er une structure pour chaque commande du pipeline


Ã‰TAPE 11 : CrÃ©er la structure de commande finale
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_triple_tab.c, parsing_triple_tab_init.c
ğŸ¯ But : Organiser tout dans une structure exploitable

Structure type :
- Commande (ex: "ls")
- Arguments (ex: ["-la", "/home"])
- Redirections d'entrÃ©e
- Redirections de sortie
- Commande suivante (si pipe)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 4 : BUILTINS (COMMANDES INTÃ‰GRÃ‰ES)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 12 : ImplÃ©menter echo
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_echo.c
ğŸ¯ But : Afficher du texte Ã  l'Ã©cran

Ce qu'il faut faire :
- Afficher tous les arguments sÃ©parÃ©s par des espaces
- Option -n : Ne pas ajouter de retour Ã  la ligne
- GÃ©rer les quotes et l'expansion de variables


Ã‰TAPE 13 : ImplÃ©menter cd
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_cd.c, builtin_cd_2.c
ğŸ¯ But : Changer de rÃ©pertoire

Ce qu'il faut faire :
- Utiliser chdir() pour changer de dossier
- cd sans argument â†’ aller au HOME
- cd - â†’ retourner au dossier prÃ©cÃ©dent (OLDPWD)
- cd .. â†’ remonter d'un niveau
- Mettre Ã  jour les variables PWD et OLDPWD


Ã‰TAPE 14 : ImplÃ©menter pwd
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_utils.c
ğŸ¯ But : Afficher le rÃ©pertoire courant

Ce qu'il faut faire :
- Utiliser getcwd() pour obtenir le chemin actuel
- Afficher ce chemin


Ã‰TAPE 15 : ImplÃ©menter export
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_export.c
ğŸ¯ But : CrÃ©er ou modifier des variables d'environnement

Ce qu'il faut faire :
- export VAR=valeur : CrÃ©er/modifier VAR
- export sans argument : Afficher toutes les variables
- GÃ©rer les erreurs (nom de variable invalide)


Ã‰TAPE 16 : ImplÃ©menter unset
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_unset.c
ğŸ¯ But : Supprimer des variables d'environnement

Ce qu'il faut faire :
- unset VAR : Supprimer la variable VAR
- Chercher la variable dans l'environnement
- La retirer de la liste


Ã‰TAPE 17 : ImplÃ©menter env
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_utils.c
ğŸ¯ But : Afficher toutes les variables d'environnement

Ce qu'il faut faire :
- Parcourir toutes les variables
- Afficher au format : NOM=valeur


Ã‰TAPE 18 : ImplÃ©menter exit
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : builtin_exit.c
ğŸ¯ But : Quitter le shell proprement

Ce qu'il faut faire :
- exit sans argument : Quitter avec le code de la derniÃ¨re commande
- exit N : Quitter avec le code N
- GÃ©rer les erreurs (exit avec argument non numÃ©rique)
- LibÃ©rer toute la mÃ©moire avant de quitter


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 5 : EXÃ‰CUTION DES COMMANDES                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 19 : Chercher les commandes dans le PATH
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : pipex_path.c
ğŸ¯ But : Trouver oÃ¹ se trouve l'exÃ©cutable d'une commande

Ce qu'il faut faire :
- RÃ©cupÃ©rer la variable PATH (contient les dossiers Ã  chercher)
- Tester chaque dossier : /usr/bin/ls, /bin/ls, etc.
- Utiliser access() pour vÃ©rifier si le fichier existe et est exÃ©cutable
- Retourner le chemin complet de la commande


Ã‰TAPE 20 : Fork et exec basique
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : exec_launch.c, minishell_exec.c
ğŸ¯ But : Lancer une commande externe (comme ls, grep, cat)

Ce qu'il faut faire :
- fork() : CrÃ©er un processus enfant
  â†’ Le parent attend, l'enfant exÃ©cute la commande
- execve() : Remplacer le processus enfant par la commande
- wait() : Le parent attend que l'enfant se termine
- RÃ©cupÃ©rer le code de retour (pour $?)


Ã‰TAPE 21 : GÃ©rer les redirections lors de l'exÃ©cution
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : exec_redir.c
ğŸ¯ But : Rediriger stdin/stdout vers des fichiers

Ce qu'il faut faire :
- Avant d'exÃ©cuter la commande :
  â†’ Ouvrir le fichier de redirection avec open()
  â†’ Utiliser dup2() pour rediriger stdin (0) ou stdout (1)
  â†’ Exemple : dup2(fd, STDOUT_FILENO) redirige la sortie vers fd
- < fichier : dup2(fd, STDIN_FILENO)
- > fichier : dup2(fd, STDOUT_FILENO)
- Fermer les fd aprÃ¨s redirection


Ã‰TAPE 22 : ImplÃ©menter les pipes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : exec_pipe.c
ğŸ¯ But : Connecter la sortie d'une commande Ã  l'entrÃ©e de la suivante

Ce qu'il faut faire :
- CrÃ©er un pipe avec pipe() â†’ donne 2 fd : [lecture, Ã©criture]
- Fork pour chaque commande
- Commande 1 : Rediriger stdout vers l'Ã©criture du pipe
- Commande 2 : Rediriger stdin vers la lecture du pipe
- Fermer les fd inutilisÃ©s dans chaque processus
- Le parent attend tous les enfants


Ã‰TAPE 23 : VÃ©rifier les erreurs d'exÃ©cution
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : exec_check.c, exec_check_exit_status.c
ğŸ¯ But : GÃ©rer les erreurs (commande introuvable, permission refusÃ©e)

Ce qu'il faut faire :
- VÃ©rifier si la commande existe
- VÃ©rifier si on a les droits d'exÃ©cution
- Afficher des messages d'erreur clairs :
  â†’ "command not found" si introuvable
  â†’ "Permission denied" si pas exÃ©cutable
- Retourner le bon code d'erreur (127 pour not found, 126 pour permission)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 6 : SIGNAUX ET GESTION DES ERREURS                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 24 : GÃ©rer les signaux (Ctrl+C, Ctrl+\, Ctrl+D)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : signals.c
ğŸ¯ But : RÃ©agir correctement aux signaux comme bash

Ce qu'il faut faire :
- Ctrl+C (SIGINT) : Afficher un nouveau prompt (ne pas quitter)
- Ctrl+\ (SIGQUIT) : Ne rien faire en mode interactif
- Ctrl+D (EOF) : Quitter le shell proprement
- Dans les commandes : Les signaux doivent fonctionner normalement


Ã‰TAPE 25 : Gestion de la mÃ©moire et leaks
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : minishell_free.c, parsing_free.c
ğŸ¯ But : LibÃ©rer toute la mÃ©moire allouÃ©e (pas de fuites)

Ce qu'il faut faire :
- CrÃ©er des fonctions de free pour chaque structure
- LibÃ©rer les listes chaÃ®nÃ©es
- LibÃ©rer l'environnement copiÃ©
- LibÃ©rer les tokens et commandes parsÃ©es
- Tester avec valgrind pour vÃ©rifier les leaks


Ã‰TAPE 26 : Gestion des erreurs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : minishell_err.c, exec_check.c
ğŸ¯ But : Afficher des messages d'erreur clairs et gÃ©rer $?

Ce qu'il faut faire :
- CrÃ©er une fonction pour afficher les erreurs sur stderr
- Stocker le code de retour de chaque commande
- Mettre Ã  jour $? aprÃ¨s chaque commande
- GÃ©rer les erreurs de parsing (quotes non fermÃ©es, etc.)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 7 : TESTS ET OPTIMISATIONS                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 27 : Tester avec des cas complexes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ Fichiers : parsing_test.c
ğŸ¯ But : VÃ©rifier que tout fonctionne comme bash

Tests Ã  faire :
- Commandes simples : ls, pwd, echo
- Commandes avec arguments : ls -la /home
- Pipes : ls | grep test | wc -l
- Redirections : echo "hello" > file.txt
- Heredocs : cat << EOF
- Variables : echo $USER $PWD
- Quotes : echo 'hello $USER' vs echo "hello $USER"
- Builtins : cd, export, unset, env, exit
- Signaux : Ctrl+C, Ctrl+D, Ctrl+\


Ã‰TAPE 28 : VÃ©rifier la norme (si projet 42)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ But : Respecter les rÃ¨gles de codage

Ce qu'il faut faire :
- Lancer norminette sur tous les fichiers
- Corriger les erreurs de norme
- VÃ©rifier les lignes trop longues (max 25 lignes par fonction)


Ã‰TAPE 29 : Optimiser et nettoyer
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Œ But : Rendre le code plus propre et efficace

Ce qu'il faut faire :
- Supprimer le code mort (fonctions inutilisÃ©es)
- Factoriser le code rÃ©pÃ©titif
- Ajouter des commentaires aux fonctions complexes
- VÃ©rifier les cas limites (NULL, strings vides, etc.)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BONUS (SI TEMPS DISPONIBLE)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BONUS 1 : OpÃ©rateurs logiques (&& et ||)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- cmd1 && cmd2 : ExÃ©cuter cmd2 seulement si cmd1 rÃ©ussit
- cmd1 || cmd2 : ExÃ©cuter cmd2 seulement si cmd1 Ã©choue

BONUS 2 : Wildcards (*)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- ls *.c : Lister tous les fichiers .c
- Expanser * en liste de fichiers correspondants

BONUS 3 : Sous-shells avec parenthÃ¨ses
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- (cd /tmp && ls) : ExÃ©cuter dans un sous-shell
- Le cd n'affecte pas le shell principal


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“š RÃ‰SUMÃ‰ DE L'ORDRE DES Ã‰TAPES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Structure de base (main, boucle, prompt)
2. Environnement et readline
3. Parsing : Tokenisation
4. Parsing : Quotes et variables
5. Parsing : Redirections et pipes
6. Builtins (echo, cd, pwd, export, unset, env, exit)
7. ExÃ©cution : PATH, fork/exec
8. ExÃ©cution : Redirections et pipes
9. Signaux
10. Gestion mÃ©moire et erreurs
11. Tests et optimisations


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’¡ CONSEILS GÃ‰NÃ‰RAUX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Tester chaque Ã©tape avant de passer Ã  la suivante
âœ… Comparer le comportement avec bash en cas de doute
âœ… Utiliser valgrind rÃ©guliÃ¨rement pour traquer les leaks
âœ… Faire des commits git aprÃ¨s chaque Ã©tape fonctionnelle
âœ… Lire le man des fonctions systÃ¨me (man fork, man execve, etc.)
âœ… Dessiner des schÃ©mas pour comprendre les pipes et redirections

ğŸ” Fonctions systÃ¨me importantes Ã  connaÃ®tre :
   - readline, add_history : Lecture de commandes
   - fork : CrÃ©er un processus
   - execve : ExÃ©cuter une commande
   - wait, waitpid : Attendre un processus
   - pipe : CrÃ©er un tube de communication
   - dup2 : Dupliquer un descripteur de fichier
   - open, close, read, write : Manipuler des fichiers
   - chdir, getcwd : GÃ©rer les rÃ©pertoires
   - signal, sigaction : GÃ©rer les signaux
   - access : VÃ©rifier l'existence/permissions d'un fichier

Bon courage ! ğŸš€
