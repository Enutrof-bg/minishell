/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_triple_tab.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevwang <kevwang@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 12:31:45 by kevwang           #+#    #+#             */
/*   Updated: 2025/07/31 12:31:45 by kevwang          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_triple_tab.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevwang <kevwang@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 12:31:45 by kevwang           #+#    #+#             */
/*   Updated: 2025/07/31 12:31:45 by kevwang          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <errno.h>  // Pour errno et EINTR

int ft_print_triple_tab(t_commande *t_cmd);
int ft_set_triple_tab_null(t_commande *t_cmd);
int ft_create_triple_tab(t_list **shell, t_commande **t_cmd, t_all **all);

// Fonctions auxiliaires pour ft_create_triple_tab
static int ft_handle_cmd_arg(t_list *shell, t_commande *t_cmd, int i);
static int ft_handle_infile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd);
static int ft_handle_limiter(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd);
static int ft_handle_outfile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd);
static int ft_handle_append(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd);

// Fonction pour gérer les arguments de commande
static int ft_handle_cmd_arg(t_list *shell, t_commande *t_cmd, int i)
{
	t_cmd->cmd_tab[i].cmd_args = ft_add_double_tab(shell->str, t_cmd->cmd_tab[i].cmd_args);
	if (!t_cmd->cmd_tab[i].cmd_args)
		return (-2); // Échec d'allocation mémoire
	return (0);
}

// Fonction pour gérer les redirections d'entrée (fichiers)
static int ft_handle_infile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd)
{
	if (*prev_infd != -1)
		close(*prev_infd);

	t_cmd->cmd_tab[i].infd = open(shell->str, O_RDONLY, 0644);
	if (t_cmd->cmd_tab[i].infd < 0)
	{
		if (t_cmd->cmd_tab[i].input_failed == 0 && t_cmd->cmd_tab[i].output_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].infd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].input_failed = 1; // Marquer que la redirection a échoué
	}
	else
		*prev_infd = t_cmd->cmd_tab[i].infd;
	
	return (0);
}

// Fonction pour gérer les redirections de sortie (fichiers)
static int ft_handle_outfile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd)
{
	if (*prev_outfd != -1)
		close(*prev_outfd);
	
	t_cmd->cmd_tab[i].outfd = open(shell->str, O_WRONLY | O_TRUNC | O_CREAT, 0644);
	if (t_cmd->cmd_tab[i].outfd < 0)
	{
		if (t_cmd->cmd_tab[i].output_failed == 0 && t_cmd->cmd_tab[i].input_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].outfd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].output_failed = 1;
	}
	else
		*prev_outfd = t_cmd->cmd_tab[i].outfd;
	
	return (0);
}

// Fonction pour gérer les redirections de sortie en mode append
static int ft_handle_append(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd)
{
	if (*prev_outfd != -1)
		close(*prev_outfd);
	
	t_cmd->cmd_tab[i].outfd = open(shell->str, O_WRONLY | O_APPEND | O_CREAT, 0644);
	if (t_cmd->cmd_tab[i].outfd < 0)
	{
		if (t_cmd->cmd_tab[i].output_failed == 0 && t_cmd->cmd_tab[i].input_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].outfd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].output_failed = 1;
	}
	else
		*prev_outfd = t_cmd->cmd_tab[i].outfd;
	
	return (0);
}

//juste initialise a NULL les char**
int ft_set_triple_tab_null(t_commande *t_cmd)
{
	int i = 0;
	while (i < t_cmd->nbr_cmd)
	{
		t_cmd->cmd_tab[i].cmd_args = NULL;
		t_cmd->cmd_tab[i].input_failed = 0;
		t_cmd->cmd_tab[i].output_failed = 0;
		t_cmd->cmd_tab[i].id1 = -1;
		t_cmd->cmd_tab[i].infd = -1;
		t_cmd->cmd_tab[i].outfd = -1;
		t_cmd->cmd_tab[i].in_str = NULL;
		t_cmd->cmd_tab[i].out_str = NULL;
		i++;
	}
	return (0);
}

int ft_create_triple_tab(t_list **shell ,t_commande **t_cmd, t_all **all)
{
	int i = 0;
	int prev_infd = -1;
    int prev_outfd = -1;
    (*t_cmd)->cmd_tab[i].infd = -1;
    (*t_cmd)->cmd_tab[i].outfd = -1;
    (*t_cmd)->cmd_tab[i].heredoc = 0;
	t_list *temp = *shell;
	while (*shell != NULL)
	{
		// if ((*shell)->state == NORMAL || (*shell)->state == DOUBLEQUOTE || (*shell)->state == SINGLEQUOTE)
		// {
		// 	(*t_cmd)->cmd_tab[i].cmd_args = ft_add_double_tab((*shell)->str, (*t_cmd)->cmd_tab[i].cmd_args);
		// 	if (!(*t_cmd)->cmd_tab[i].cmd_args)
		// 		return (*shell = temp, -2);
		// }
		if ((*shell)->state == INFILE && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			if (prev_infd != -1)
				close(prev_infd);
			(*t_cmd)->cmd_tab[i].infd = open((*shell)->str, O_RDONLY, 0644);
			if ((*t_cmd)->cmd_tab[i].infd < 0)
			{
				if ((*t_cmd)->cmd_tab[i].input_failed == 0 && (*t_cmd)->cmd_tab[i].output_failed == 0)
					perror((*shell)->str);
				(*all)->exit_status = 1; // Set exit status to indicate error
				(*t_cmd)->cmd_tab[i].infd = -1; // Marquer comme échec
				(*t_cmd)->cmd_tab[i].input_failed = 1; // Marquer que la redirection a échoué
			}
			else
				prev_infd = (*t_cmd)->cmd_tab[i].infd;
		}
		if ((*shell)->state == LIMITER && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			if (prev_infd != -1)
				close(prev_infd);
			(*t_cmd)->cmd_tab[i].infd = open("temp", O_WRONLY | O_CREAT | O_APPEND, 0644);
			if ((*t_cmd)->cmd_tab[i].infd < 0)
			{
				// perror((*shell)->str);
				if ((*t_cmd)->cmd_tab[i].input_failed == 0 && (*t_cmd)->cmd_tab[i].output_failed == 0)
					perror((*shell)->str);
					// (*t_cmd)->cmd_tab[i].in_str = (*shell)->str;
				(*all)->exit_status = 1; // Set exit status to indicate error
				(*t_cmd)->cmd_tab[i].infd = -1; // Marquer comme échec
				(*t_cmd)->cmd_tab[i].input_failed = 1; // Marquer que la redirection a échoué
				// Ne pas retourner -1, continuer le parsing
			}
			else
			{
				signal(SIGINT, SIG_IGN);
				(*t_cmd)->cmd_tab[i].id_here_doc = fork();
				if ((*t_cmd)->cmd_tab[i].id_here_doc == 0)
				{
					signal(SIGINT, SIG_DFL);
					signal(SIGQUIT, SIG_IGN);
					if (tcgetattr(STDIN_FILENO, &(*all)->term) == 0)
                    {
                        (*all)->term.c_lflag &= ~0001000; // Désactiver ECHOCTL pour ne pas afficher les caractères de contrôle
                        tcsetattr(STDIN_FILENO, TCSANOW,  &(*all)->term);
                    }
					(*t_cmd)->cmd_tab[i].heredoc++;
					if (access("temp", F_OK) == 0)
					{
						close((*t_cmd)->cmd_tab[i].infd);
						unlink("temp");
					}
					(*t_cmd)->cmd_tab[i].infd  = open("temp", O_WRONLY | O_CREAT | O_APPEND, 0644);
					//protec open

					char *test = get_next_line(0);
					while (test && g_sigvaleur == 0)
					{
						if (ft_strncmp(test, (*shell)->str, ft_strlen((*shell)->str)) == 0)
						{
							free(test);
							break ;
						}
						write((*t_cmd)->cmd_tab[i].infd, test, ft_strlen(test));
						free(test);
						test = get_next_line(0);
					}

					close((*t_cmd)->cmd_tab[i].infd);
					exit(0);  // IMPORTANT: Sortir du processus enfant
				}
				else
				{
					// Processus parent: attendre la fin du heredoc
					int status;
					waitpid((*t_cmd)->cmd_tab[i].id_here_doc, &status, 0);
					signal(SIGINT, ft_test);
					if (WIFSIGNALED(status))
					{
						int sig = WTERMSIG(status);
						if (sig == SIGINT)
						{
							write (1, "^C\n", 3);
							(*all)->exit_status = 128 + sig;
							return (-1);
						}
					}
					close((*t_cmd)->cmd_tab[i].infd);  // Fermer le fd d'écriture
					// unlink("temp");
					(*t_cmd)->cmd_tab[i].infd = open("temp", O_RDONLY, 0644);
					if ((*t_cmd)->cmd_tab[i].infd < 0)
					{
						perror("temp");
						(*t_cmd)->cmd_tab[i].input_failed = 1;
					}
					else
					{
						prev_infd = (*t_cmd)->cmd_tab[i].infd;
					}
				}
			}	
		}
		if ((*shell)->state == OUTFILE && (*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			if (prev_outfd != -1)
				close(prev_outfd);
			(*t_cmd)->cmd_tab[i].outfd = open((*shell)->str, O_WRONLY | O_TRUNC | O_CREAT, 0644);
			if ((*t_cmd)->cmd_tab[i].outfd < 0)
			{
				if ((*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
					perror((*shell)->str);
				(*all)->exit_status = 1; // Set exit status to indicate error
				(*t_cmd)->cmd_tab[i].outfd = -1; // Marquer comme échec
				(*t_cmd)->cmd_tab[i].output_failed = 1;
			}
			else
				prev_outfd = (*t_cmd)->cmd_tab[i].outfd;
		}
		if ((*shell)->state == OUTFILEAPPEND && (*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
	    {
	        if (prev_outfd != -1)
	            close(prev_outfd);
	        (*t_cmd)->cmd_tab[i].outfd = open((*shell)->str, O_WRONLY | O_APPEND | O_CREAT, 0644);
	        if ((*t_cmd)->cmd_tab[i].outfd < 0)
	        {
	            if ((*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
	            	perror((*shell)->str);
				(*all)->exit_status = 1; // Set exit status to indicate error
				(*t_cmd)->cmd_tab[i].outfd = -1; // Marquer comme échec
				(*t_cmd)->cmd_tab[i].output_failed = 1;
	        }
			else
	        	prev_outfd = (*t_cmd)->cmd_tab[i].outfd;
	    }
		if ((*shell)->state == PIPE)
		{
			i++;
			(*t_cmd)->cmd_tab[i].infd = -1;
			(*t_cmd)->cmd_tab[i].outfd = -1;
			(*t_cmd)->cmd_tab[i].input_failed = 0;
			(*t_cmd)->cmd_tab[i].output_failed = 0;
			(*t_cmd)->cmd_tab[i].in_str = NULL;
			(*t_cmd)->cmd_tab[i].out_str = NULL;
			prev_infd = -1;
			prev_outfd = -1;
		}
		(*shell) = (*shell)->next;
	}
	(*shell) = temp;
	return (0);
}
