/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_triple_tab.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevwang <kevwang@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 12:31:45 by kevwang           #+#    #+#             */
/*   Updated: 2025/07/31 12:31:45 by kevwang          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_triple_tab.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevwang <kevwang@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 12:31:45 by kevwang           #+#    #+#             */
/*   Updated: 2025/07/31 12:31:45 by kevwang          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <errno.h>  // Pour errno et EINTR

int ft_print_triple_tab(t_commande *t_cmd);
int ft_set_triple_tab_null(t_commande *t_cmd);
int ft_create_triple_tab(t_list **shell, t_commande **t_cmd, t_all **all);

// Fonctions auxiliaires pour ft_create_triple_tab
static int ft_handle_cmd_arg(t_list *shell, t_commande *t_cmd, int i);
static int ft_handle_infile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd);
static int ft_handle_limiter(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd);
static int ft_handle_outfile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd);
static int ft_handle_append(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd);
static int ft_handle_pipe(t_commande *t_cmd, int *i, int *prev_infd, int *prev_outfd);

int ft_print_triple_tab(t_commande *t_cmd)
{
	int j;

	j = 0;
	while (j < t_cmd->nbr_cmd)
	{
		if (t_cmd->cmd_tab[j].cmd_args)
		{
			printf("tab:%d\n", j);
			ft_print_tab(t_cmd->cmd_tab[j].cmd_args);
			printf("infd:%d\n", t_cmd->cmd_tab[j].infd);
			printf("outfd:%d\n", t_cmd->cmd_tab[j].outfd);
		}
		j++;
	}
	return (0);
}

//juste initialise a NULL les char**
int ft_set_triple_tab_null(t_commande *t_cmd)
{
	int i = 0;
	while (i < t_cmd->nbr_cmd)
	{
		t_cmd->cmd_tab[i].cmd_args = NULL;
		t_cmd->cmd_tab[i].input_failed = 0;
		t_cmd->cmd_tab[i].output_failed = 0;
		t_cmd->cmd_tab[i].id1 = -1;
		t_cmd->cmd_tab[i].infd = -1;
		t_cmd->cmd_tab[i].outfd = -1;
		t_cmd->cmd_tab[i].in_str = NULL;
		t_cmd->cmd_tab[i].out_str = NULL;
		i++;
	}
	return (0);
}

// Fonction pour gérer les arguments de commande
static int ft_handle_cmd_arg(t_list *shell, t_commande *t_cmd, int i)
{
	t_cmd->cmd_tab[i].cmd_args = ft_add_double_tab(shell->str, t_cmd->cmd_tab[i].cmd_args);
	if (!t_cmd->cmd_tab[i].cmd_args)
		return (-2); // Échec d'allocation mémoire
	return (0);
}

// Fonction pour gérer les redirections d'entrée (fichiers)
static int ft_handle_infile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd)
{
	if (*prev_infd != -1)
		close(*prev_infd);

	t_cmd->cmd_tab[i].infd = open(shell->str, O_RDONLY, 0644);
	if (t_cmd->cmd_tab[i].infd < 0)
	{
		if (t_cmd->cmd_tab[i].input_failed == 0 && t_cmd->cmd_tab[i].output_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].infd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].input_failed = 1; // Marquer que la redirection a échoué
	}
	else
		*prev_infd = t_cmd->cmd_tab[i].infd;
	
	return (0);
}

// Gestion du processus enfant heredoc
static int ft_handle_heredoc_child(t_list *shell, t_commande *t_cmd, t_all *all, int i)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_IGN);
	
	if (tcgetattr(STDIN_FILENO, &all->term) == 0)
	{
		all->term.c_lflag &= ~0001000; // Désactiver ECHOCTL
		tcsetattr(STDIN_FILENO, TCSANOW, &all->term);
	}
	
	t_cmd->cmd_tab[i].heredoc++;
	if (access("temp", F_OK) == 0)
	{
		close(t_cmd->cmd_tab[i].infd);
		unlink("temp");
	}
	
	t_cmd->cmd_tab[i].infd = open("temp", O_WRONLY | O_CREAT | O_APPEND, 0644);
	//protec open
	
	char *test = get_next_line(0);
	while (test && g_sigvaleur == 0)
	{
		if (ft_strncmp(test, shell->str, ft_strlen(shell->str)) == 0)
		{
			free(test);
			break;
		}
		write(t_cmd->cmd_tab[i].infd, test, ft_strlen(test));
		free(test);
		test = get_next_line(0);
	}
	
	close(t_cmd->cmd_tab[i].infd);
	exit(0);
}

// Fonction pour gérer les redirections d'entrée via heredoc
static int ft_handle_limiter(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_infd)
{
	if (*prev_infd != -1)
		close(*prev_infd);
	
	t_cmd->cmd_tab[i].infd = open("temp", O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (t_cmd->cmd_tab[i].infd < 0)
	{
		if (t_cmd->cmd_tab[i].input_failed == 0 && t_cmd->cmd_tab[i].output_failed == 0)
			perror(shell->str);
		all->exit_status = 1;
		t_cmd->cmd_tab[i].infd = -1;
		t_cmd->cmd_tab[i].input_failed = 1;
		return (0); // Continue parsing
	}
	
	signal(SIGINT, SIG_IGN);
	t_cmd->cmd_tab[i].id_here_doc = fork();
	
	if (t_cmd->cmd_tab[i].id_here_doc == 0)
	{
		ft_handle_heredoc_child(shell, t_cmd, all, i);
	}
	else
	{
		// Processus parent: attendre la fin du heredoc
		int status;
		waitpid(t_cmd->cmd_tab[i].id_here_doc, &status, 0);
		signal(SIGINT, ft_test);
		
		if (WIFSIGNALED(status))
		{
			int sig = WTERMSIG(status);
			if (sig == SIGINT)
			{
				write(1, "^C\n", 3);
				all->exit_status = 128 + sig;
				return (-1);
			}
		}
		
		close(t_cmd->cmd_tab[i].infd);
		t_cmd->cmd_tab[i].infd = open("temp", O_RDONLY, 0644);
		
		if (t_cmd->cmd_tab[i].infd < 0)
		{
			perror("temp");
			t_cmd->cmd_tab[i].input_failed = 1;
		}
		else
		{
			*prev_infd = t_cmd->cmd_tab[i].infd;
		}
	}
	
	return (0);
}

// Fonction pour gérer les redirections de sortie (fichiers)
static int ft_handle_outfile(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd)
{
	if (*prev_outfd != -1)
		close(*prev_outfd);
	
	t_cmd->cmd_tab[i].outfd = open(shell->str, O_WRONLY | O_TRUNC | O_CREAT, 0644);
	if (t_cmd->cmd_tab[i].outfd < 0)
	{
		if (t_cmd->cmd_tab[i].output_failed == 0 && t_cmd->cmd_tab[i].input_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].outfd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].output_failed = 1;
	}
	else
		*prev_outfd = t_cmd->cmd_tab[i].outfd;
	
	return (0);
}

// Fonction pour gérer les redirections de sortie en mode append
static int ft_handle_append(t_list *shell, t_commande *t_cmd, t_all *all, int i, int *prev_outfd)
{
	if (*prev_outfd != -1)
		close(*prev_outfd);
	
	t_cmd->cmd_tab[i].outfd = open(shell->str, O_WRONLY | O_APPEND | O_CREAT, 0644);
	if (t_cmd->cmd_tab[i].outfd < 0)
	{
		if (t_cmd->cmd_tab[i].output_failed == 0 && t_cmd->cmd_tab[i].input_failed == 0)
			perror(shell->str);
		all->exit_status = 1; // Set exit status to indicate error
		t_cmd->cmd_tab[i].outfd = -1; // Marquer comme échec
		t_cmd->cmd_tab[i].output_failed = 1;
	}
	else
		*prev_outfd = t_cmd->cmd_tab[i].outfd;
	
	return (0);
}

// Fonction pour gérer les pipes
static int ft_handle_pipe(t_commande *t_cmd, int *i, int *prev_infd, int *prev_outfd)
{
	(*i)++;
	t_cmd->cmd_tab[*i].infd = -1;
	t_cmd->cmd_tab[*i].outfd = -1;
	t_cmd->cmd_tab[*i].input_failed = 0;
	t_cmd->cmd_tab[*i].output_failed = 0;
	t_cmd->cmd_tab[*i].in_str = NULL;
	t_cmd->cmd_tab[*i].out_str = NULL;
	*prev_infd = -1;
	*prev_outfd = -1;
	
	return (0);
}

// Fonction principale refactorisée
int ft_create_triple_tab(t_list **shell, t_commande **t_cmd, t_all **all)
{
	int i = 0;
	int prev_infd = -1;
	int prev_outfd = -1;
	int result;
	
	(*t_cmd)->cmd_tab[i].infd = -1;
	(*t_cmd)->cmd_tab[i].outfd = -1;
	(*t_cmd)->cmd_tab[i].heredoc = 0;
	
	t_list *temp = *shell;
	while (*shell != NULL)
	{
		if ((*shell)->state == NORMAL || (*shell)->state == DOUBLEQUOTE || (*shell)->state == SINGLEQUOTE)
		{
			result = ft_handle_cmd_arg(*shell, *t_cmd, i);
			if (result == -2)
				return (*shell = temp, -2);
		}
		else if ((*shell)->state == INFILE && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			ft_handle_infile(*shell, *t_cmd, *all, i, &prev_infd);
		}
		else if ((*shell)->state == LIMITER && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			result = ft_handle_limiter(*shell, *t_cmd, *all, i, &prev_infd);
			if (result == -1)
				return (*shell = temp, -1);
		}
		else if ((*shell)->state == OUTFILE && (*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			ft_handle_outfile(*shell, *t_cmd, *all, i, &prev_outfd);
		}
		else if ((*shell)->state == OUTFILEAPPEND && (*t_cmd)->cmd_tab[i].output_failed == 0 && (*t_cmd)->cmd_tab[i].input_failed == 0)
		{
			ft_handle_append(*shell, *t_cmd, *all, i, &prev_outfd);
		}
		else if ((*shell)->state == PIPE)
		{
			ft_handle_pipe(*t_cmd, &i, &prev_infd, &prev_outfd);
		}
		
		(*shell) = (*shell)->next;
	}
	
	(*shell) = temp;
	return (0);
}
